import { Component, Input, Output, EventEmitter } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import * as i0 from "@angular/core";
import * as i1 from "../data.service";
import * as i2 from "@angular/common";
import * as i3 from "@angular/forms";
import * as i4 from "@angular/material/form-field";
import * as i5 from "@angular/material/input";
import * as i6 from "@angular/cdk/text-field";
export class SqlTextareaComponent {
    ngAfterViewInit() {
    }
    constructor(_dataService) {
        this._dataService = _dataService;
        this.value = '';
        this.fieldData = '';
        this.rows = '5';
        this.maxrows = '10';
        this.col = '';
        this.class = '';
        this.style = '';
        this.hint = '';
        this.icon = '';
        this.label = 'Label not set';
        this.placeholder = '';
        this.appearance = 'outline';
        this.bs_row = 'Y';
        this.bs_col = 'col-12';
        this.top_label = 'N';
        this.counter = 0;
        this.change = new EventEmitter();
        this.myObs = this._dataService.dataSubject.subscribe(d => {
            this.data = d;
            this.fieldData = this.data;
            this.value = this.fieldData[this.col];
            this.counter++;
        });
    }
    ngOnInit() {
    }
    handleChange() {
        this.fieldData['submit'] = 'N';
        this.fieldData[this.col] = this.value;
        this._dataService.pushNotification(this.fieldData);
    }
    ngOnDestroy() {
        this.myObs.unsubscribe();
    }
}
SqlTextareaComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.3", ngImport: i0, type: SqlTextareaComponent, deps: [{ token: i1.SQLDataService }], target: i0.ɵɵFactoryTarget.Component });
SqlTextareaComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.3", type: SqlTextareaComponent, isStandalone: true, selector: "sql-textarea", inputs: { rows: "rows", maxrows: "maxrows", col: "col", data: "data", class: "class", style: "style", hint: "hint", icon: "icon", label: "label", placeholder: "placeholder", appearance: "appearance", bs_row: "bs_row", bs_col: "bs_col", top_label: "top_label" }, outputs: { change: "change" }, ngImport: i0, template: "<div class=\"container-fluid\">\n    <!-- mat appearance is outline -->\n    <div *ngIf=\"appearance=='outline'\">\n      <!-- if new row -->\n          <div *ngIf=\"bs_row=='Y'\" class=\"row\">\n            <div [class]=\"bs_col\">\n                <p *ngIf=\"top_label=='Y'\">{{ label }}</p>\n                <mat-form-field appearance=\"outline\" [style]=\"style\" [class]=\"class\">\n                  <mat-label>{{ label }}</mat-label>\n                  <textarea (change)=\"handleChange()\" [(ngModel)]=\"value\" matInput\n                            cdkTextareaAutosize\n                            #autosize=\"cdkTextareaAutosize\"\n                            cdkAutosizeMinRows=\"{{ rows}}\"\n                            cdkAutosizeMaxRows=\"{{ maxrows }}\"></textarea>\n                </mat-form-field>  \n            </div>\n          </div>\n      <!-- if not new row but has bootstrap column-->\n      <div *ngIf=\"bs_row!='Y'&&bs_col!=''\">\n        <div [class]=\"bs_col\">\n            <p *ngIf=\"top_label=='Y'\">{{ label }}</p>\n            <mat-form-field appearance=\"outline\" [style]=\"style\" [class]=\"class\">\n              <mat-label>{{ label }}</mat-label>\n              <textarea (change)=\"handleChange()\" [(ngModel)]=\"value\" matInput\n                        cdkTextareaAutosize\n                        #autosize=\"cdkTextareaAutosize\"\n                        cdkAutosizeMinRows=\"{{ rows}}\"\n                        cdkAutosizeMaxRows=\"{{ maxrows }}\"></textarea>\n            </mat-form-field>  \n        </div>\n      </div>\n      <!-- if not new row and no bootstrap column -->\n      <div *ngIf=\"bs_row!='Y'&&bs_col==''\">\n        <p *ngIf=\"top_label=='Y'\">{{ label }}</p>\n        <mat-form-field appearance=\"outline\" [style]=\"style\" [class]=\"class\">\n          <mat-label>{{ label }}</mat-label>\n          <textarea (change)=\"handleChange()\" [(ngModel)]=\"value\" matInput\n                    cdkTextareaAutosize\n                    #autosize=\"cdkTextareaAutosize\"\n                    cdkAutosizeMinRows=\"{{ rows}}\"\n                    cdkAutosizeMaxRows=\"{{ maxrows }}\"></textarea>\n        </mat-form-field>  \n      </div>\n    </div>\n    <!-- mat appearance is fill -->    \n    <div *ngIf=\"appearance=='fill'\">\n      <!-- if new row -->\n      <div *ngIf=\"bs_row=='Y'\" class=\"row\">\n        <div [class]=\"bs_col\">\n          <p *ngIf=\"top_label=='Y'\">{{ label }}</p>\n          <mat-form-field appearance=\"fill\" [style]=\"style\" [class]=\"class\">\n            <mat-label>{{ label }}</mat-label>\n            <textarea (change)=\"handleChange()\" [(ngModel)]=\"value\" matInput\n                      cdkTextareaAutosize\n                      #autosize=\"cdkTextareaAutosize\"\n                      cdkAutosizeMinRows=\"{{ rows}}\"\n                      cdkAutosizeMaxRows=\"{{ maxrows }}\"></textarea>\n          </mat-form-field>  \n        </div>\n      </div>\n            <!-- if not new row but has bootstrap column-->\n            <div *ngIf=\"bs_row!='Y'&&bs_col!=''\">\n              <div [class]=\"bs_col\">\n                <p *ngIf=\"top_label=='Y'\">{{ label }}</p>\n                <mat-form-field appearance=\"fill\" [style]=\"style\" [class]=\"class\">\n                  <mat-label>{{ label }}</mat-label>\n                  <textarea (change)=\"handleChange()\" [(ngModel)]=\"value\" matInput\n                            cdkTextareaAutosize\n                            #autosize=\"cdkTextareaAutosize\"\n                            cdkAutosizeMinRows=\"{{ rows}}\"\n                            cdkAutosizeMaxRows=\"{{ maxrows }}\"></textarea>\n                </mat-form-field>  \n              </div>\n            </div>\n            <div *ngIf=\"bs_row!='Y'&&bs_col==''\">\n                <p *ngIf=\"top_label=='Y'\">{{ label }}</p>\n                <mat-form-field appearance=\"fill\" [style]=\"style\" [class]=\"class\">\n                  <mat-label>{{ label }}</mat-label>\n                  <textarea (change)=\"handleChange()\" [(ngModel)]=\"value\" matInput\n                            cdkTextareaAutosize\n                            #autosize=\"cdkTextareaAutosize\"\n                            cdkAutosizeMinRows=\"{{ rows}}\"\n                            cdkAutosizeMaxRows=\"{{ maxrows }}\"></textarea>\n                </mat-form-field>  \n          </div>\n\n    </div>\n</div> ", styles: [""], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i3.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "ngmodule", type: MatFormFieldModule }, { kind: "component", type: i4.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i4.MatLabel, selector: "mat-label" }, { kind: "ngmodule", type: MatInputModule }, { kind: "directive", type: i5.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "directive", type: i6.CdkTextareaAutosize, selector: "textarea[cdkTextareaAutosize]", inputs: ["cdkAutosizeMinRows", "cdkAutosizeMaxRows", "cdkTextareaAutosize", "placeholder"], exportAs: ["cdkTextareaAutosize"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.3", ngImport: i0, type: SqlTextareaComponent, decorators: [{
            type: Component,
            args: [{ selector: 'sql-textarea', standalone: true, imports: [CommonModule, FormsModule, MatFormFieldModule, MatInputModule], template: "<div class=\"container-fluid\">\n    <!-- mat appearance is outline -->\n    <div *ngIf=\"appearance=='outline'\">\n      <!-- if new row -->\n          <div *ngIf=\"bs_row=='Y'\" class=\"row\">\n            <div [class]=\"bs_col\">\n                <p *ngIf=\"top_label=='Y'\">{{ label }}</p>\n                <mat-form-field appearance=\"outline\" [style]=\"style\" [class]=\"class\">\n                  <mat-label>{{ label }}</mat-label>\n                  <textarea (change)=\"handleChange()\" [(ngModel)]=\"value\" matInput\n                            cdkTextareaAutosize\n                            #autosize=\"cdkTextareaAutosize\"\n                            cdkAutosizeMinRows=\"{{ rows}}\"\n                            cdkAutosizeMaxRows=\"{{ maxrows }}\"></textarea>\n                </mat-form-field>  \n            </div>\n          </div>\n      <!-- if not new row but has bootstrap column-->\n      <div *ngIf=\"bs_row!='Y'&&bs_col!=''\">\n        <div [class]=\"bs_col\">\n            <p *ngIf=\"top_label=='Y'\">{{ label }}</p>\n            <mat-form-field appearance=\"outline\" [style]=\"style\" [class]=\"class\">\n              <mat-label>{{ label }}</mat-label>\n              <textarea (change)=\"handleChange()\" [(ngModel)]=\"value\" matInput\n                        cdkTextareaAutosize\n                        #autosize=\"cdkTextareaAutosize\"\n                        cdkAutosizeMinRows=\"{{ rows}}\"\n                        cdkAutosizeMaxRows=\"{{ maxrows }}\"></textarea>\n            </mat-form-field>  \n        </div>\n      </div>\n      <!-- if not new row and no bootstrap column -->\n      <div *ngIf=\"bs_row!='Y'&&bs_col==''\">\n        <p *ngIf=\"top_label=='Y'\">{{ label }}</p>\n        <mat-form-field appearance=\"outline\" [style]=\"style\" [class]=\"class\">\n          <mat-label>{{ label }}</mat-label>\n          <textarea (change)=\"handleChange()\" [(ngModel)]=\"value\" matInput\n                    cdkTextareaAutosize\n                    #autosize=\"cdkTextareaAutosize\"\n                    cdkAutosizeMinRows=\"{{ rows}}\"\n                    cdkAutosizeMaxRows=\"{{ maxrows }}\"></textarea>\n        </mat-form-field>  \n      </div>\n    </div>\n    <!-- mat appearance is fill -->    \n    <div *ngIf=\"appearance=='fill'\">\n      <!-- if new row -->\n      <div *ngIf=\"bs_row=='Y'\" class=\"row\">\n        <div [class]=\"bs_col\">\n          <p *ngIf=\"top_label=='Y'\">{{ label }}</p>\n          <mat-form-field appearance=\"fill\" [style]=\"style\" [class]=\"class\">\n            <mat-label>{{ label }}</mat-label>\n            <textarea (change)=\"handleChange()\" [(ngModel)]=\"value\" matInput\n                      cdkTextareaAutosize\n                      #autosize=\"cdkTextareaAutosize\"\n                      cdkAutosizeMinRows=\"{{ rows}}\"\n                      cdkAutosizeMaxRows=\"{{ maxrows }}\"></textarea>\n          </mat-form-field>  \n        </div>\n      </div>\n            <!-- if not new row but has bootstrap column-->\n            <div *ngIf=\"bs_row!='Y'&&bs_col!=''\">\n              <div [class]=\"bs_col\">\n                <p *ngIf=\"top_label=='Y'\">{{ label }}</p>\n                <mat-form-field appearance=\"fill\" [style]=\"style\" [class]=\"class\">\n                  <mat-label>{{ label }}</mat-label>\n                  <textarea (change)=\"handleChange()\" [(ngModel)]=\"value\" matInput\n                            cdkTextareaAutosize\n                            #autosize=\"cdkTextareaAutosize\"\n                            cdkAutosizeMinRows=\"{{ rows}}\"\n                            cdkAutosizeMaxRows=\"{{ maxrows }}\"></textarea>\n                </mat-form-field>  \n              </div>\n            </div>\n            <div *ngIf=\"bs_row!='Y'&&bs_col==''\">\n                <p *ngIf=\"top_label=='Y'\">{{ label }}</p>\n                <mat-form-field appearance=\"fill\" [style]=\"style\" [class]=\"class\">\n                  <mat-label>{{ label }}</mat-label>\n                  <textarea (change)=\"handleChange()\" [(ngModel)]=\"value\" matInput\n                            cdkTextareaAutosize\n                            #autosize=\"cdkTextareaAutosize\"\n                            cdkAutosizeMinRows=\"{{ rows}}\"\n                            cdkAutosizeMaxRows=\"{{ maxrows }}\"></textarea>\n                </mat-form-field>  \n          </div>\n\n    </div>\n</div> " }]
        }], ctorParameters: function () { return [{ type: i1.SQLDataService }]; }, propDecorators: { rows: [{
                type: Input
            }], maxrows: [{
                type: Input
            }], col: [{
                type: Input
            }], data: [{
                type: Input
            }], class: [{
                type: Input
            }], style: [{
                type: Input
            }], hint: [{
                type: Input
            }], icon: [{
                type: Input
            }], label: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], appearance: [{
                type: Input
            }], bs_row: [{
                type: Input
            }], bs_col: [{
                type: Input
            }], top_label: [{
                type: Input
            }], change: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3FsLXRleHRhcmVhLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3NxbC1jb21wb25lbnRzL3NyYy9saWIvc3FsLXRleHRhcmVhL3NxbC10ZXh0YXJlYS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9zcWwtY29tcG9uZW50cy9zcmMvbGliL3NxbC10ZXh0YXJlYS9zcWwtdGV4dGFyZWEuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBVSxLQUFLLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBZ0QsTUFBTSxlQUFlLENBQUM7QUFDN0gsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsa0JBQWtCLEVBQXVCLE1BQU0sOEJBQThCLENBQUM7QUFDdkYsT0FBTyxFQUFZLGNBQWMsRUFBRSxNQUFNLHlCQUF5QixDQUFDOzs7Ozs7OztBQWFuRSxNQUFNLE9BQU8sb0JBQW9CO0lBd0IvQixlQUFlO0lBRWYsQ0FBQztJQUdELFlBQW9CLFlBQTRCO1FBQTVCLGlCQUFZLEdBQVosWUFBWSxDQUFnQjtRQTNCaEQsVUFBSyxHQUFNLEVBQUUsQ0FBQztRQUNkLGNBQVMsR0FBUSxFQUFFLENBQUM7UUFHWCxTQUFJLEdBQVEsR0FBRyxDQUFDO1FBQ2hCLFlBQU8sR0FBUSxJQUFJLENBQUM7UUFDcEIsUUFBRyxHQUFXLEVBQUUsQ0FBQztRQUVqQixVQUFLLEdBQVEsRUFBRSxDQUFDO1FBQ2hCLFVBQUssR0FBUSxFQUFFLENBQUM7UUFDaEIsU0FBSSxHQUFXLEVBQUUsQ0FBQztRQUNsQixTQUFJLEdBQVcsRUFBRSxDQUFDO1FBQ2xCLFVBQUssR0FBVyxlQUFlLENBQUM7UUFDaEMsZ0JBQVcsR0FBUSxFQUFFLENBQUM7UUFDdEIsZUFBVSxHQUFXLFNBQVMsQ0FBQztRQUMvQixXQUFNLEdBQVEsR0FBRyxDQUFDO1FBQ2xCLFdBQU0sR0FBUSxRQUFRLENBQUM7UUFDdkIsY0FBUyxHQUFRLEdBQUcsQ0FBQztRQUM5QixZQUFPLEdBQVcsQ0FBQyxDQUFDO1FBRXBCLFdBQU0sR0FBc0IsSUFBSSxZQUFZLEVBQU8sQ0FBQztRQVFsRCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUN2RCxJQUFJLENBQUMsSUFBSSxHQUFDLENBQUMsQ0FBQztZQUNaLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztZQUMzQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3RDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNqQixDQUFDLENBQUMsQ0FBQTtJQUNKLENBQUM7SUFFRCxRQUFRO0lBRVIsQ0FBQztJQUdELFlBQVk7UUFDVCxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxHQUFDLEdBQUcsQ0FBQztRQUM3QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3BDLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUMzQixDQUFDOztpSEFuRFUsb0JBQW9CO3FHQUFwQixvQkFBb0IsNldDakJqQyxnMElBdUZPLHlERDFFSyxZQUFZLGtJQUFFLFdBQVcsOG1CQUFFLGtCQUFrQiwwU0FBRSxjQUFjOzJGQUk1RCxvQkFBb0I7a0JBUGhDLFNBQVM7K0JBQ0UsY0FBYyxjQUNaLElBQUksV0FDUCxDQUFDLFlBQVksRUFBRSxXQUFXLEVBQUUsa0JBQWtCLEVBQUUsY0FBYyxDQUFDO3FHQVUvRCxJQUFJO3NCQUFaLEtBQUs7Z0JBQ0csT0FBTztzQkFBZixLQUFLO2dCQUNHLEdBQUc7c0JBQVgsS0FBSztnQkFDRyxJQUFJO3NCQUFaLEtBQUs7Z0JBQ0csS0FBSztzQkFBYixLQUFLO2dCQUNHLEtBQUs7c0JBQWIsS0FBSztnQkFDRyxJQUFJO3NCQUFaLEtBQUs7Z0JBQ0csSUFBSTtzQkFBWixLQUFLO2dCQUNHLEtBQUs7c0JBQWIsS0FBSztnQkFDRyxXQUFXO3NCQUFuQixLQUFLO2dCQUNHLFVBQVU7c0JBQWxCLEtBQUs7Z0JBQ0csTUFBTTtzQkFBZCxLQUFLO2dCQUNHLE1BQU07c0JBQWQsS0FBSztnQkFDRyxTQUFTO3NCQUFqQixLQUFLO2dCQUdOLE1BQU07c0JBREwsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBEb0NoZWNrLCBBZnRlclZpZXdJbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBNYXRGb3JtRmllbGRNb2R1bGUsIE1hdEZvcm1GaWVsZENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9mb3JtLWZpZWxkJztcbmltcG9ydCB7IE1hdElucHV0LCBNYXRJbnB1dE1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2lucHV0JztcbmltcG9ydCB7IE1hdEljb25Nb2R1bGUgIH0gIGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2ljb24nO1xuaW1wb3J0IHsgU1FMRGF0YVNlcnZpY2UgfSBmcm9tICcuLi9kYXRhLnNlcnZpY2UnOyBcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3NxbC10ZXh0YXJlYScsXG4gIHN0YW5kYWxvbmU6IHRydWUsXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEZvcm1zTW9kdWxlLCBNYXRGb3JtRmllbGRNb2R1bGUsIE1hdElucHV0TW9kdWxlXSxcbiAgdGVtcGxhdGVVcmw6ICcuL3NxbC10ZXh0YXJlYS5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL3NxbC10ZXh0YXJlYS5jb21wb25lbnQuY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgU3FsVGV4dGFyZWFDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSAge1xuXG4gIHZhbHVlOiBhbnk9Jyc7XG4gIGZpZWxkRGF0YTogYW55ID0gJyc7XG4gIG15T2JzITogU3Vic2NyaXB0aW9uO1xuXG4gIEBJbnB1dCgpIHJvd3M6IGFueSA9ICc1JztcbiAgQElucHV0KCkgbWF4cm93czogYW55ID0gJzEwJztcbiAgQElucHV0KCkgY29sOiBzdHJpbmcgPSAnJztcbiAgQElucHV0KCkgZGF0YTogYW55O1xuICBASW5wdXQoKSBjbGFzczogYW55ID0gJyc7XG4gIEBJbnB1dCgpIHN0eWxlOiBhbnkgPSAnJztcbiAgQElucHV0KCkgaGludDogc3RyaW5nID0gJyc7XG4gIEBJbnB1dCgpIGljb246IHN0cmluZyA9ICcnO1xuICBASW5wdXQoKSBsYWJlbDogc3RyaW5nID0gJ0xhYmVsIG5vdCBzZXQnO1xuICBASW5wdXQoKSBwbGFjZWhvbGRlcjogYW55ID0gJyc7XG4gIEBJbnB1dCgpIGFwcGVhcmFuY2U6IHN0cmluZyA9ICdvdXRsaW5lJztcbiAgQElucHV0KCkgYnNfcm93OiBhbnkgPSAnWSc7XG4gIEBJbnB1dCgpIGJzX2NvbDogYW55ID0gJ2NvbC0xMic7XG4gIEBJbnB1dCgpIHRvcF9sYWJlbDogYW55ID0gJ04nO1xuICBjb3VudGVyOiBudW1iZXIgPSAwO1xuICBAT3V0cHV0KClcbiAgY2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpOyAgXG4gIFxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG5cbiAgfVxuXG4gIGZvcm1EYXRhOiBhbnk7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2RhdGFTZXJ2aWNlOiBTUUxEYXRhU2VydmljZSkgeyBcbiAgICB0aGlzLm15T2JzID0gdGhpcy5fZGF0YVNlcnZpY2UuZGF0YVN1YmplY3Quc3Vic2NyaWJlKGQgPT4ge1xuICAgICAgdGhpcy5kYXRhPWQ7XG4gICAgICB0aGlzLmZpZWxkRGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmZpZWxkRGF0YVt0aGlzLmNvbF07XG4gICAgICB0aGlzLmNvdW50ZXIrKztcbiAgICB9KVxuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgfVxuXG5cbiAgaGFuZGxlQ2hhbmdlKCkge1xuICAgICB0aGlzLmZpZWxkRGF0YVsnc3VibWl0J109J04nO1xuICAgICB0aGlzLmZpZWxkRGF0YVt0aGlzLmNvbF09dGhpcy52YWx1ZTtcbiAgICAgdGhpcy5fZGF0YVNlcnZpY2UucHVzaE5vdGlmaWNhdGlvbih0aGlzLmZpZWxkRGF0YSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLm15T2JzLnVuc3Vic2NyaWJlKCk7XG4gIH1cbn0iLCI8ZGl2IGNsYXNzPVwiY29udGFpbmVyLWZsdWlkXCI+XG4gICAgPCEtLSBtYXQgYXBwZWFyYW5jZSBpcyBvdXRsaW5lIC0tPlxuICAgIDxkaXYgKm5nSWY9XCJhcHBlYXJhbmNlPT0nb3V0bGluZSdcIj5cbiAgICAgIDwhLS0gaWYgbmV3IHJvdyAtLT5cbiAgICAgICAgICA8ZGl2ICpuZ0lmPVwiYnNfcm93PT0nWSdcIiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgPGRpdiBbY2xhc3NdPVwiYnNfY29sXCI+XG4gICAgICAgICAgICAgICAgPHAgKm5nSWY9XCJ0b3BfbGFiZWw9PSdZJ1wiPnt7IGxhYmVsIH19PC9wPlxuICAgICAgICAgICAgICAgIDxtYXQtZm9ybS1maWVsZCBhcHBlYXJhbmNlPVwib3V0bGluZVwiIFtzdHlsZV09XCJzdHlsZVwiIFtjbGFzc109XCJjbGFzc1wiPlxuICAgICAgICAgICAgICAgICAgPG1hdC1sYWJlbD57eyBsYWJlbCB9fTwvbWF0LWxhYmVsPlxuICAgICAgICAgICAgICAgICAgPHRleHRhcmVhIChjaGFuZ2UpPVwiaGFuZGxlQ2hhbmdlKClcIiBbKG5nTW9kZWwpXT1cInZhbHVlXCIgbWF0SW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZGtUZXh0YXJlYUF1dG9zaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgI2F1dG9zaXplPVwiY2RrVGV4dGFyZWFBdXRvc2l6ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2RrQXV0b3NpemVNaW5Sb3dzPVwie3sgcm93c319XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZGtBdXRvc2l6ZU1heFJvd3M9XCJ7eyBtYXhyb3dzIH19XCI+PC90ZXh0YXJlYT5cbiAgICAgICAgICAgICAgICA8L21hdC1mb3JtLWZpZWxkPiAgXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgIDwhLS0gaWYgbm90IG5ldyByb3cgYnV0IGhhcyBib290c3RyYXAgY29sdW1uLS0+XG4gICAgICA8ZGl2ICpuZ0lmPVwiYnNfcm93IT0nWScmJmJzX2NvbCE9JydcIj5cbiAgICAgICAgPGRpdiBbY2xhc3NdPVwiYnNfY29sXCI+XG4gICAgICAgICAgICA8cCAqbmdJZj1cInRvcF9sYWJlbD09J1knXCI+e3sgbGFiZWwgfX08L3A+XG4gICAgICAgICAgICA8bWF0LWZvcm0tZmllbGQgYXBwZWFyYW5jZT1cIm91dGxpbmVcIiBbc3R5bGVdPVwic3R5bGVcIiBbY2xhc3NdPVwiY2xhc3NcIj5cbiAgICAgICAgICAgICAgPG1hdC1sYWJlbD57eyBsYWJlbCB9fTwvbWF0LWxhYmVsPlxuICAgICAgICAgICAgICA8dGV4dGFyZWEgKGNoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoKVwiIFsobmdNb2RlbCldPVwidmFsdWVcIiBtYXRJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgY2RrVGV4dGFyZWFBdXRvc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgI2F1dG9zaXplPVwiY2RrVGV4dGFyZWFBdXRvc2l6ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjZGtBdXRvc2l6ZU1pblJvd3M9XCJ7eyByb3dzfX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2RrQXV0b3NpemVNYXhSb3dzPVwie3sgbWF4cm93cyB9fVwiPjwvdGV4dGFyZWE+XG4gICAgICAgICAgICA8L21hdC1mb3JtLWZpZWxkPiAgXG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8IS0tIGlmIG5vdCBuZXcgcm93IGFuZCBubyBib290c3RyYXAgY29sdW1uIC0tPlxuICAgICAgPGRpdiAqbmdJZj1cImJzX3JvdyE9J1knJiZic19jb2w9PScnXCI+XG4gICAgICAgIDxwICpuZ0lmPVwidG9wX2xhYmVsPT0nWSdcIj57eyBsYWJlbCB9fTwvcD5cbiAgICAgICAgPG1hdC1mb3JtLWZpZWxkIGFwcGVhcmFuY2U9XCJvdXRsaW5lXCIgW3N0eWxlXT1cInN0eWxlXCIgW2NsYXNzXT1cImNsYXNzXCI+XG4gICAgICAgICAgPG1hdC1sYWJlbD57eyBsYWJlbCB9fTwvbWF0LWxhYmVsPlxuICAgICAgICAgIDx0ZXh0YXJlYSAoY2hhbmdlKT1cImhhbmRsZUNoYW5nZSgpXCIgWyhuZ01vZGVsKV09XCJ2YWx1ZVwiIG1hdElucHV0XG4gICAgICAgICAgICAgICAgICAgIGNka1RleHRhcmVhQXV0b3NpemVcbiAgICAgICAgICAgICAgICAgICAgI2F1dG9zaXplPVwiY2RrVGV4dGFyZWFBdXRvc2l6ZVwiXG4gICAgICAgICAgICAgICAgICAgIGNka0F1dG9zaXplTWluUm93cz1cInt7IHJvd3N9fVwiXG4gICAgICAgICAgICAgICAgICAgIGNka0F1dG9zaXplTWF4Um93cz1cInt7IG1heHJvd3MgfX1cIj48L3RleHRhcmVhPlxuICAgICAgICA8L21hdC1mb3JtLWZpZWxkPiAgXG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8IS0tIG1hdCBhcHBlYXJhbmNlIGlzIGZpbGwgLS0+ICAgIFxuICAgIDxkaXYgKm5nSWY9XCJhcHBlYXJhbmNlPT0nZmlsbCdcIj5cbiAgICAgIDwhLS0gaWYgbmV3IHJvdyAtLT5cbiAgICAgIDxkaXYgKm5nSWY9XCJic19yb3c9PSdZJ1wiIGNsYXNzPVwicm93XCI+XG4gICAgICAgIDxkaXYgW2NsYXNzXT1cImJzX2NvbFwiPlxuICAgICAgICAgIDxwICpuZ0lmPVwidG9wX2xhYmVsPT0nWSdcIj57eyBsYWJlbCB9fTwvcD5cbiAgICAgICAgICA8bWF0LWZvcm0tZmllbGQgYXBwZWFyYW5jZT1cImZpbGxcIiBbc3R5bGVdPVwic3R5bGVcIiBbY2xhc3NdPVwiY2xhc3NcIj5cbiAgICAgICAgICAgIDxtYXQtbGFiZWw+e3sgbGFiZWwgfX08L21hdC1sYWJlbD5cbiAgICAgICAgICAgIDx0ZXh0YXJlYSAoY2hhbmdlKT1cImhhbmRsZUNoYW5nZSgpXCIgWyhuZ01vZGVsKV09XCJ2YWx1ZVwiIG1hdElucHV0XG4gICAgICAgICAgICAgICAgICAgICAgY2RrVGV4dGFyZWFBdXRvc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICNhdXRvc2l6ZT1cImNka1RleHRhcmVhQXV0b3NpemVcIlxuICAgICAgICAgICAgICAgICAgICAgIGNka0F1dG9zaXplTWluUm93cz1cInt7IHJvd3N9fVwiXG4gICAgICAgICAgICAgICAgICAgICAgY2RrQXV0b3NpemVNYXhSb3dzPVwie3sgbWF4cm93cyB9fVwiPjwvdGV4dGFyZWE+XG4gICAgICAgICAgPC9tYXQtZm9ybS1maWVsZD4gIFxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPCEtLSBpZiBub3QgbmV3IHJvdyBidXQgaGFzIGJvb3RzdHJhcCBjb2x1bW4tLT5cbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XCJic19yb3chPSdZJyYmYnNfY29sIT0nJ1wiPlxuICAgICAgICAgICAgICA8ZGl2IFtjbGFzc109XCJic19jb2xcIj5cbiAgICAgICAgICAgICAgICA8cCAqbmdJZj1cInRvcF9sYWJlbD09J1knXCI+e3sgbGFiZWwgfX08L3A+XG4gICAgICAgICAgICAgICAgPG1hdC1mb3JtLWZpZWxkIGFwcGVhcmFuY2U9XCJmaWxsXCIgW3N0eWxlXT1cInN0eWxlXCIgW2NsYXNzXT1cImNsYXNzXCI+XG4gICAgICAgICAgICAgICAgICA8bWF0LWxhYmVsPnt7IGxhYmVsIH19PC9tYXQtbGFiZWw+XG4gICAgICAgICAgICAgICAgICA8dGV4dGFyZWEgKGNoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoKVwiIFsobmdNb2RlbCldPVwidmFsdWVcIiBtYXRJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNka1RleHRhcmVhQXV0b3NpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjYXV0b3NpemU9XCJjZGtUZXh0YXJlYUF1dG9zaXplXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZGtBdXRvc2l6ZU1pblJvd3M9XCJ7eyByb3dzfX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNka0F1dG9zaXplTWF4Um93cz1cInt7IG1heHJvd3MgfX1cIj48L3RleHRhcmVhPlxuICAgICAgICAgICAgICAgIDwvbWF0LWZvcm0tZmllbGQ+ICBcbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XCJic19yb3chPSdZJyYmYnNfY29sPT0nJ1wiPlxuICAgICAgICAgICAgICAgIDxwICpuZ0lmPVwidG9wX2xhYmVsPT0nWSdcIj57eyBsYWJlbCB9fTwvcD5cbiAgICAgICAgICAgICAgICA8bWF0LWZvcm0tZmllbGQgYXBwZWFyYW5jZT1cImZpbGxcIiBbc3R5bGVdPVwic3R5bGVcIiBbY2xhc3NdPVwiY2xhc3NcIj5cbiAgICAgICAgICAgICAgICAgIDxtYXQtbGFiZWw+e3sgbGFiZWwgfX08L21hdC1sYWJlbD5cbiAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSAoY2hhbmdlKT1cImhhbmRsZUNoYW5nZSgpXCIgWyhuZ01vZGVsKV09XCJ2YWx1ZVwiIG1hdElucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2RrVGV4dGFyZWFBdXRvc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICNhdXRvc2l6ZT1cImNka1RleHRhcmVhQXV0b3NpemVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNka0F1dG9zaXplTWluUm93cz1cInt7IHJvd3N9fVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2RrQXV0b3NpemVNYXhSb3dzPVwie3sgbWF4cm93cyB9fVwiPjwvdGV4dGFyZWE+XG4gICAgICAgICAgICAgICAgPC9tYXQtZm9ybS1maWVsZD4gIFxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG48L2Rpdj4gIl19