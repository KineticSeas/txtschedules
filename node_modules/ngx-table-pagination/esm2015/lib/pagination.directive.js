import { ChangeDetectorRef, Directive, EventEmitter, Input, Output, } from '@angular/core';
import { PaginationService } from './pagination.service';
/**
 * This directive is what powers all pagination controls components, including the default one.
 * It exposes an API which is hooked up to the PaginationService to keep the PaginatePipe in sync
 * with the pagination controls.
 */
export class PaginationDirective {
    constructor(service, changeDetectorRef) {
        this.service = service;
        this.changeDetectorRef = changeDetectorRef;
        this.maxSize = 7;
        this.pageChange = new EventEmitter();
        this.pageBoundsCorrection = new EventEmitter();
        this.pages = [];
        this.pageSizes = [];
        this.changeSub = this.service.change.subscribe((id) => {
            if (this.id === id) {
                this.updatePageLinks();
                this.changeDetectorRef.markForCheck();
                this.changeDetectorRef.detectChanges();
                const inst = this.service.getInstance(this.id);
                this.itemsPerPage = inst.itemsPerPage;
            }
        });
    }
    ngOnInit() {
        if (this.id === undefined) {
            this.id = this.service.defaultId();
        }
        const inst = this.service.getInstance(this.id);
        this.itemsPerPage = inst.itemsPerPage;
        for (let i = 5; i <= inst.totalItems;) {
            this.pageSizes.push(i);
            i += 5;
        }
        this.updatePageLinks();
    }
    ngOnChanges(changes) {
        this.updatePageLinks();
    }
    ngOnDestroy() {
        this.changeSub.unsubscribe();
    }
    pageSizeChanged(event) {
        this.itemsPerPage = event;
        this.service.setItemsPerPage(this.id, event);
        this.setCurrent(1);
        this.updatePageLinks();
    }
    /**
     * Go to the previous page
     */
    previous() {
        this.checkValidId();
        this.setCurrent(this.getCurrent() - 1);
    }
    /**
     * Go to the next page
     */
    next() {
        this.checkValidId();
        this.setCurrent(this.getCurrent() + 1);
    }
    /**
     * Returns true if current page is first page
     */
    isFirstPage() {
        return this.getCurrent() === 1;
    }
    /**
     * Returns true if current page is last page
     */
    isLastPage() {
        return this.getLastPage() === this.getCurrent();
    }
    /**
     * Set the current page number.
     */
    setCurrent(page) {
        this.pageChange.emit(page);
    }
    /**
     * Get the current page number.
     */
    getCurrent() {
        return this.service.getCurrentPage(this.id);
    }
    /**
     * Returns the last page number
     */
    getLastPage() {
        const inst = this.service.getInstance(this.id);
        if (inst.totalItems < 1) {
            // when there are 0 or fewer (an error case) items, there are no "pages" as such,
            // but it makes sense to consider a single, empty page as the last page.
            return 1;
        }
        return Math.ceil(inst.totalItems / inst.itemsPerPage);
    }
    getTotalItems() {
        return this.service.getInstance(this.id).totalItems;
    }
    getStartIndex() {
        const inst = this.service.getInstance(this.id);
        if (inst.totalItems < inst.itemsPerPage * (inst.currentPage - 1) + 1) {
            this.setCurrent(1);
        }
        return inst.itemsPerPage * (inst.currentPage - 1) + 1;
    }
    getEndIndex() {
        const inst = this.service.getInstance(this.id);
        const end = inst.itemsPerPage * inst.currentPage;
        if (inst.totalItems < end) {
            return inst.totalItems;
        }
        return end;
    }
    checkValidId() {
        if (this.service.getInstance(this.id).id == null) {
            console.warn(`PaginationControlsDirective: the specified id "${this.id}" does not match any registered PaginationInstance`);
        }
    }
    /**
     * Updates the page links and checks that the current page is valid. Should run whenever the
     * PaginationService.change stream emits a value matching the current ID, or when any of the
     * input values changes.
     */
    updatePageLinks() {
        const inst = this.service.getInstance(this.id);
        const correctedCurrentPage = this.outOfBoundCorrection(inst);
        if (correctedCurrentPage !== inst.currentPage) {
            setTimeout(() => {
                this.pageBoundsCorrection.emit(correctedCurrentPage);
                this.pages = this.createPageArray(inst.currentPage, inst.itemsPerPage, inst.totalItems, this.maxSize);
            });
        }
        else {
            this.pages = this.createPageArray(inst.currentPage, inst.itemsPerPage, inst.totalItems, this.maxSize);
        }
    }
    /**
     * Checks that the instance.currentPage property is within bounds for the current page range.
     * If not, return a correct value for currentPage, or the current value if OK.
     */
    outOfBoundCorrection(instance) {
        const totalPages = Math.ceil(instance.totalItems / instance.itemsPerPage);
        if (totalPages < instance.currentPage && 0 < totalPages) {
            return totalPages;
        }
        else if (instance.currentPage < 1) {
            return 1;
        }
        return instance.currentPage;
    }
    /**
     * Returns an array of Page objects to use in the pagination controls.
     */
    createPageArray(currentPage, itemsPerPage, totalItems, paginationRange) {
        // paginationRange could be a string if passed from attribute, so cast to number.
        paginationRange = +paginationRange;
        const pages = [];
        const totalPages = Math.ceil(totalItems / itemsPerPage);
        const halfWay = Math.ceil(paginationRange / 2);
        const isStart = currentPage <= halfWay;
        const isEnd = totalPages - halfWay < currentPage;
        const isMiddle = !isStart && !isEnd;
        const ellipsesNeeded = paginationRange < totalPages;
        let i = 1;
        while (i <= totalPages && i <= paginationRange) {
            let label;
            const pageNumber = this.calculatePageNumber(i, currentPage, paginationRange, totalPages);
            const openingEllipsesNeeded = i === 2 && (isMiddle || isEnd);
            const closingEllipsesNeeded = i === paginationRange - 1 && (isMiddle || isStart);
            if (ellipsesNeeded && (openingEllipsesNeeded || closingEllipsesNeeded)) {
                label = '...';
            }
            else {
                label = pageNumber;
            }
            pages.push({
                label,
                value: pageNumber,
            });
            i++;
        }
        return pages;
    }
    /**
     * Given the position in the sequence of pagination links [i],
     * figure out what page number corresponds to that position.
     */
    calculatePageNumber(i, currentPage, paginationRange, totalPages) {
        const halfWay = Math.ceil(paginationRange / 2);
        if (i === paginationRange) {
            return totalPages;
        }
        else if (i === 1) {
            return i;
        }
        else if (paginationRange < totalPages) {
            if (totalPages - halfWay < currentPage) {
                return totalPages - paginationRange + i;
            }
            else if (halfWay < currentPage) {
                return currentPage - halfWay + i;
            }
            else {
                return i;
            }
        }
        else {
            return i;
        }
    }
}
PaginationDirective.decorators = [
    { type: Directive, args: [{
                selector: 'pagination-template,[pagination-template]',
                exportAs: 'paginationApi',
            },] }
];
PaginationDirective.ctorParameters = () => [
    { type: PaginationService },
    { type: ChangeDetectorRef }
];
PaginationDirective.propDecorators = {
    id: [{ type: Input }],
    maxSize: [{ type: Input }],
    pageChange: [{ type: Output }],
    pageBoundsCorrection: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnaW5hdGlvbi5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiQzovQWRyZW5hbGluZVdTL2RlbW9zL25neC10YWJsZS1wYWdpbmF0aW9uL3Byb2plY3RzL25neC10YWJsZS1wYWdpbmF0aW9uL3NyYy8iLCJzb3VyY2VzIjpbImxpYi9wYWdpbmF0aW9uLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sR0FFUCxNQUFNLGVBQWUsQ0FBQztBQUd2QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQVF6RDs7OztHQUlHO0FBS0gsTUFBTSxPQUFPLG1CQUFtQjtJQWE5QixZQUNVLE9BQTBCLEVBQzFCLGlCQUFvQztRQURwQyxZQUFPLEdBQVAsT0FBTyxDQUFtQjtRQUMxQixzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO1FBYnJDLFlBQU8sR0FBRyxDQUFDLENBQUM7UUFFWCxlQUFVLEdBQXlCLElBQUksWUFBWSxFQUFVLENBQUM7UUFDOUQseUJBQW9CLEdBQXlCLElBQUksWUFBWSxFQUVwRSxDQUFDO1FBQ0osVUFBSyxHQUFXLEVBQUUsQ0FBQztRQUNuQixjQUFTLEdBQVUsRUFBRSxDQUFDO1FBUXBCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUU7WUFDcEQsSUFBSSxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRTtnQkFDbEIsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO2dCQUN2QixJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxFQUFFLENBQUM7Z0JBQ3RDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLEVBQUUsQ0FBQztnQkFDdkMsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxX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Q0wsS0FBSyxFQUFFLFVBQVU7YUFDbEIsQ0FBQyxDQUFDO1lBQ0gsQ0FBQyxFQUFFLENBQUM7U0FDTDtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7T0FHRztJQUNLLG1CQUFtQixDQUN6QixDQUFTLEVBQ1QsV0FBbUIsRUFDbkIsZUFBdUIsRUFDdkIsVUFBa0I7UUFFbEIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLEtBQUssZUFBZSxFQUFFO1lBQ3pCLE9BQU8sVUFBVSxDQUFDO1NBQ25CO2FBQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2xCLE9BQU8sQ0FBQyxDQUFDO1NBQ1Y7YUFBTSxJQUFJLGVBQWUsR0FBRyxVQUFVLEVBQUU7WUFDdkMsSUFBSSxVQUFVLEdBQUcsT0FBTyxHQUFHLFdBQVcsRUFBRTtnQkFDdEMsT0FBTyxVQUFVLEdBQUcsZUFBZSxHQUFHLENBQUMsQ0FBQzthQUN6QztpQkFBTSxJQUFJLE9BQU8sR0FBRyxXQUFXLEVBQUU7Z0JBQ2hDLE9BQU8sV0FBVyxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUM7YUFDbEM7aUJBQU07Z0JBQ0wsT0FBTyxDQUFDLENBQUM7YUFDVjtTQUNGO2FBQU07WUFDTCxPQUFPLENBQUMsQ0FBQztTQUNWO0lBQ0gsQ0FBQzs7O1lBblFGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsMkNBQTJDO2dCQUNyRCxRQUFRLEVBQUUsZUFBZTthQUMxQjs7O1lBaEJRLGlCQUFpQjtZQVR4QixpQkFBaUI7OztpQkEyQmhCLEtBQUs7c0JBQ0wsS0FBSzt5QkFFTCxNQUFNO21DQUNOLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIENoYW5nZURldGVjdG9yUmVmLFxyXG4gIERpcmVjdGl2ZSxcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgSW5wdXQsXHJcbiAgT3V0cHV0LFxyXG4gIE9uSW5pdCxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQgeyBQYWdpbmF0aW9uU2VydmljZSB9IGZyb20gJy4vcGFnaW5hdGlvbi5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUGFnaW5hdGlvbkluc3RhbmNlIH0gZnJvbSAnLi9wYWdpbmF0aW9uLWluc3RhbmNlJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGFnZSB7XHJcbiAgbGFiZWw6IHN0cmluZztcclxuICB2YWx1ZTogYW55O1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBkaXJlY3RpdmUgaXMgd2hhdCBwb3dlcnMgYWxsIHBhZ2luYXRpb24gY29udHJvbHMgY29tcG9uZW50cywgaW5jbHVkaW5nIHRoZSBkZWZhdWx0IG9uZS5cclxuICogSXQgZXhwb3NlcyBhbiBBUEkgd2hpY2ggaXMgaG9va2VkIHVwIHRvIHRoZSBQYWdpbmF0aW9uU2VydmljZSB0byBrZWVwIHRoZSBQYWdpbmF0ZVBpcGUgaW4gc3luY1xyXG4gKiB3aXRoIHRoZSBwYWdpbmF0aW9uIGNvbnRyb2xzLlxyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdwYWdpbmF0aW9uLXRlbXBsYXRlLFtwYWdpbmF0aW9uLXRlbXBsYXRlXScsXHJcbiAgZXhwb3J0QXM6ICdwYWdpbmF0aW9uQXBpJyxcclxufSlcclxuZXhwb3J0IGNsYXNzIFBhZ2luYXRpb25EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQge1xyXG4gIEBJbnB1dCgpIGlkOiBzdHJpbmc7XHJcbiAgQElucHV0KCkgbWF4U2l6ZSA9IDc7XHJcblxyXG4gIEBPdXRwdXQoKSBwYWdlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xyXG4gIEBPdXRwdXQoKSBwYWdlQm91bmRzQ29ycmVjdGlvbjogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyPFxyXG4gICAgbnVtYmVyXHJcbiAgPigpO1xyXG4gIHBhZ2VzOiBQYWdlW10gPSBbXTtcclxuICBwYWdlU2l6ZXM6IGFueVtdID0gW107XHJcbiAgaXRlbXNQZXJQYWdlOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBjaGFuZ2VTdWI6IFN1YnNjcmlwdGlvbjtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIHNlcnZpY2U6IFBhZ2luYXRpb25TZXJ2aWNlLFxyXG4gICAgcHJpdmF0ZSBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWZcclxuICApIHtcclxuICAgIHRoaXMuY2hhbmdlU3ViID0gdGhpcy5zZXJ2aWNlLmNoYW5nZS5zdWJzY3JpYmUoKGlkKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmlkID09PSBpZCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlUGFnZUxpbmtzKCk7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcclxuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcclxuICAgICAgICBjb25zdCBpbnN0ID0gdGhpcy5zZXJ2aWNlLmdldEluc3RhbmNlKHRoaXMuaWQpO1xyXG4gICAgICAgIHRoaXMuaXRlbXNQZXJQYWdlID0gaW5zdC5pdGVtc1BlclBhZ2U7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgbmdPbkluaXQoKSB7XHJcbiAgICBpZiAodGhpcy5pZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuaWQgPSB0aGlzLnNlcnZpY2UuZGVmYXVsdElkKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnN0ID0gdGhpcy5zZXJ2aWNlLmdldEluc3RhbmNlKHRoaXMuaWQpO1xyXG4gICAgdGhpcy5pdGVtc1BlclBhZ2UgPSBpbnN0Lml0ZW1zUGVyUGFnZTtcclxuICAgIGZvciAobGV0IGkgPSA1OyBpIDw9IGluc3QudG90YWxJdGVtczsgKSB7XHJcbiAgICAgIHRoaXMucGFnZVNpemVzLnB1c2goaSk7XHJcbiAgICAgIGkgKz0gNTtcclxuICAgIH1cclxuICAgIHRoaXMudXBkYXRlUGFnZUxpbmtzKCk7XHJcbiAgfVxyXG5cclxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBhbnkpIHtcclxuICAgIHRoaXMudXBkYXRlUGFnZUxpbmtzKCk7XHJcbiAgfVxyXG5cclxuICBuZ09uRGVzdHJveSgpIHtcclxuICAgIHRoaXMuY2hhbmdlU3ViLnVuc3Vic2NyaWJlKCk7XHJcbiAgfVxyXG4gIHBhZ2VTaXplQ2hhbmdlZChldmVudCkge1xyXG4gICAgdGhpcy5pdGVtc1BlclBhZ2UgPSBldmVudDtcclxuICAgIHRoaXMuc2VydmljZS5zZXRJdGVtc1BlclBhZ2UodGhpcy5pZCwgZXZlbnQpO1xyXG4gICAgdGhpcy5zZXRDdXJyZW50KDEpO1xyXG4gICAgdGhpcy51cGRhdGVQYWdlTGlua3MoKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogR28gdG8gdGhlIHByZXZpb3VzIHBhZ2VcclxuICAgKi9cclxuICBwcmV2aW91cygpIHtcclxuICAgIHRoaXMuY2hlY2tWYWxpZElkKCk7XHJcbiAgICB0aGlzLnNldEN1cnJlbnQodGhpcy5nZXRDdXJyZW50KCkgLSAxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdvIHRvIHRoZSBuZXh0IHBhZ2VcclxuICAgKi9cclxuICBuZXh0KCkge1xyXG4gICAgdGhpcy5jaGVja1ZhbGlkSWQoKTtcclxuICAgIHRoaXMuc2V0Q3VycmVudCh0aGlzLmdldEN1cnJlbnQoKSArIDEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIGN1cnJlbnQgcGFnZSBpcyBmaXJzdCBwYWdlXHJcbiAgICovXHJcbiAgaXNGaXJzdFBhZ2UoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50KCkgPT09IDE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgY3VycmVudCBwYWdlIGlzIGxhc3QgcGFnZVxyXG4gICAqL1xyXG4gIGlzTGFzdFBhZ2UoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRMYXN0UGFnZSgpID09PSB0aGlzLmdldEN1cnJlbnQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgY3VycmVudCBwYWdlIG51bWJlci5cclxuICAgKi9cclxuICBzZXRDdXJyZW50KHBhZ2U6IG51bWJlcikge1xyXG4gICAgdGhpcy5wYWdlQ2hhbmdlLmVtaXQocGFnZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGN1cnJlbnQgcGFnZSBudW1iZXIuXHJcbiAgICovXHJcbiAgZ2V0Q3VycmVudCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VydmljZS5nZXRDdXJyZW50UGFnZSh0aGlzLmlkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGxhc3QgcGFnZSBudW1iZXJcclxuICAgKi9cclxuICBnZXRMYXN0UGFnZSgpOiBudW1iZXIge1xyXG4gICAgY29uc3QgaW5zdCA9IHRoaXMuc2VydmljZS5nZXRJbnN0YW5jZSh0aGlzLmlkKTtcclxuICAgIGlmIChpbnN0LnRvdGFsSXRlbXMgPCAxKSB7XHJcbiAgICAgIC8vIHdoZW4gdGhlcmUgYXJlIDAgb3IgZmV3ZXIgKGFuIGVycm9yIGNhc2UpIGl0ZW1zLCB0aGVyZSBhcmUgbm8gXCJwYWdlc1wiIGFzIHN1Y2gsXHJcbiAgICAgIC8vIGJ1dCBpdCBtYWtlcyBzZW5zZSB0byBjb25zaWRlciBhIHNpbmdsZSwgZW1wdHkgcGFnZSBhcyB0aGUgbGFzdCBwYWdlLlxyXG4gICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIHJldHVybiBNYXRoLmNlaWwoaW5zdC50b3RhbEl0ZW1zIC8gaW5zdC5pdGVtc1BlclBhZ2UpO1xyXG4gIH1cclxuXHJcbiAgZ2V0VG90YWxJdGVtcygpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VydmljZS5nZXRJbnN0YW5jZSh0aGlzLmlkKS50b3RhbEl0ZW1zO1xyXG4gIH1cclxuICBnZXRTdGFydEluZGV4KCk6IG51bWJlciB7XHJcbiAgICBjb25zdCBpbnN0ID0gdGhpcy5zZXJ2aWNlLmdldEluc3RhbmNlKHRoaXMuaWQpO1xyXG4gICAgaWYgKGluc3QudG90YWxJdGVtcyA8IGluc3QuaXRlbXNQZXJQYWdlICogKGluc3QuY3VycmVudFBhZ2UgLSAxKSArIDEpIHtcclxuICAgICAgdGhpcy5zZXRDdXJyZW50KDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluc3QuaXRlbXNQZXJQYWdlICogKGluc3QuY3VycmVudFBhZ2UgLSAxKSArIDE7XHJcbiAgfVxyXG5cclxuICBnZXRFbmRJbmRleCgpOiBudW1iZXIge1xyXG4gICAgY29uc3QgaW5zdCA9IHRoaXMuc2VydmljZS5nZXRJbnN0YW5jZSh0aGlzLmlkKTtcclxuICAgIGNvbnN0IGVuZCA9IGluc3QuaXRlbXNQZXJQYWdlICogaW5zdC5jdXJyZW50UGFnZTtcclxuICAgIGlmIChpbnN0LnRvdGFsSXRlbXMgPCBlbmQpIHtcclxuICAgICAgcmV0dXJuIGluc3QudG90YWxJdGVtcztcclxuICAgIH1cclxuICAgIHJldHVybiBlbmQ7XHJcbiAgfVxyXG4gIHByaXZhdGUgY2hlY2tWYWxpZElkKCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuc2VydmljZS5nZXRJbnN0YW5jZSh0aGlzLmlkKS5pZCA9PSBudWxsKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgUGFnaW5hdGlvbkNvbnRyb2xzRGlyZWN0aXZlOiB0aGUgc3BlY2lmaWVkIGlkIFwiJHt0aGlzLmlkfVwiIGRvZXMgbm90IG1hdGNoIGFueSByZWdpc3RlcmVkIFBhZ2luYXRpb25JbnN0YW5jZWBcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIHBhZ2UgbGlua3MgYW5kIGNoZWNrcyB0aGF0IHRoZSBjdXJyZW50IHBhZ2UgaXMgdmFsaWQuIFNob3VsZCBydW4gd2hlbmV2ZXIgdGhlXHJcbiAgICogUGFnaW5hdGlvblNlcnZpY2UuY2hhbmdlIHN0cmVhbSBlbWl0cyBhIHZhbHVlIG1hdGNoaW5nIHRoZSBjdXJyZW50IElELCBvciB3aGVuIGFueSBvZiB0aGVcclxuICAgKiBpbnB1dCB2YWx1ZXMgY2hhbmdlcy5cclxuICAgKi9cclxuICBwcml2YXRlIHVwZGF0ZVBhZ2VMaW5rcygpIHtcclxuICAgIGNvbnN0IGluc3QgPSB0aGlzLnNlcnZpY2UuZ2V0SW5zdGFuY2UodGhpcy5pZCk7XHJcbiAgICBjb25zdCBjb3JyZWN0ZWRDdXJyZW50UGFnZSA9IHRoaXMub3V0T2ZCb3VuZENvcnJlY3Rpb24oaW5zdCk7XHJcblxyXG4gICAgaWYgKGNvcnJlY3RlZEN1cnJlbnRQYWdlICE9PSBpbnN0LmN1cnJlbnRQYWdlKSB7XHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMucGFnZUJvdW5kc0NvcnJlY3Rpb24uZW1pdChjb3JyZWN0ZWRDdXJyZW50UGFnZSk7XHJcbiAgICAgICAgdGhpcy5wYWdlcyA9IHRoaXMuY3JlYXRlUGFnZUFycmF5KFxyXG4gICAgICAgICAgaW5zdC5jdXJyZW50UGFnZSxcclxuICAgICAgICAgIGluc3QuaXRlbXNQZXJQYWdlLFxyXG4gICAgICAgICAgaW5zdC50b3RhbEl0ZW1zLFxyXG4gICAgICAgICAgdGhpcy5tYXhTaXplXHJcbiAgICAgICAgKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnBhZ2VzID0gdGhpcy5jcmVhdGVQYWdlQXJyYXkoXHJcbiAgICAgICAgaW5zdC5jdXJyZW50UGFnZSxcclxuICAgICAgICBpbnN0Lml0ZW1zUGVyUGFnZSxcclxuICAgICAgICBpbnN0LnRvdGFsSXRlbXMsXHJcbiAgICAgICAgdGhpcy5tYXhTaXplXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgdGhhdCB0aGUgaW5zdGFuY2UuY3VycmVudFBhZ2UgcHJvcGVydHkgaXMgd2l0aGluIGJvdW5kcyBmb3IgdGhlIGN1cnJlbnQgcGFnZSByYW5nZS5cclxuICAgKiBJZiBub3QsIHJldHVybiBhIGNvcnJlY3QgdmFsdWUgZm9yIGN1cnJlbnRQYWdlLCBvciB0aGUgY3VycmVudCB2YWx1ZSBpZiBPSy5cclxuICAgKi9cclxuICBwcml2YXRlIG91dE9mQm91bmRDb3JyZWN0aW9uKGluc3RhbmNlOiBQYWdpbmF0aW9uSW5zdGFuY2UpOiBudW1iZXIge1xyXG4gICAgY29uc3QgdG90YWxQYWdlcyA9IE1hdGguY2VpbChpbnN0YW5jZS50b3RhbEl0ZW1zIC8gaW5zdGFuY2UuaXRlbXNQZXJQYWdlKTtcclxuICAgIGlmICh0b3RhbFBhZ2VzIDwgaW5zdGFuY2UuY3VycmVudFBhZ2UgJiYgMCA8IHRvdGFsUGFnZXMpIHtcclxuICAgICAgcmV0dXJuIHRvdGFsUGFnZXM7XHJcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmN1cnJlbnRQYWdlIDwgMSkge1xyXG4gICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW5zdGFuY2UuY3VycmVudFBhZ2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIFBhZ2Ugb2JqZWN0cyB0byB1c2UgaW4gdGhlIHBhZ2luYXRpb24gY29udHJvbHMuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjcmVhdGVQYWdlQXJyYXkoXHJcbiAgICBjdXJyZW50UGFnZTogbnVtYmVyLFxyXG4gICAgaXRlbXNQZXJQYWdlOiBudW1iZXIsXHJcbiAgICB0b3RhbEl0ZW1zOiBudW1iZXIsXHJcbiAgICBwYWdpbmF0aW9uUmFuZ2U6IG51bWJlclxyXG4gICk6IFBhZ2VbXSB7XHJcbiAgICAvLyBwYWdpbmF0aW9uUmFuZ2UgY291bGQgYmUgYSBzdHJpbmcgaWYgcGFzc2VkIGZyb20gYXR0cmlidXRlLCBzbyBjYXN0IHRvIG51bWJlci5cclxuICAgIHBhZ2luYXRpb25SYW5nZSA9ICtwYWdpbmF0aW9uUmFuZ2U7XHJcbiAgICBjb25zdCBwYWdlcyA9IFtdO1xyXG4gICAgY29uc3QgdG90YWxQYWdlcyA9IE1hdGguY2VpbCh0b3RhbEl0ZW1zIC8gaXRlbXNQZXJQYWdlKTtcclxuICAgIGNvbnN0IGhhbGZXYXkgPSBNYXRoLmNlaWwocGFnaW5hdGlvblJhbmdlIC8gMik7XHJcblxyXG4gICAgY29uc3QgaXNTdGFydCA9IGN1cnJlbnRQYWdlIDw9IGhhbGZXYXk7XHJcbiAgICBjb25zdCBpc0VuZCA9IHRvdGFsUGFnZXMgLSBoYWxmV2F5IDwgY3VycmVudFBhZ2U7XHJcbiAgICBjb25zdCBpc01pZGRsZSA9ICFpc1N0YXJ0ICYmICFpc0VuZDtcclxuXHJcbiAgICBjb25zdCBlbGxpcHNlc05lZWRlZCA9IHBhZ2luYXRpb25SYW5nZSA8IHRvdGFsUGFnZXM7XHJcbiAgICBsZXQgaSA9IDE7XHJcblxyXG4gICAgd2hpbGUgKGkgPD0gdG90YWxQYWdlcyAmJiBpIDw9IHBhZ2luYXRpb25SYW5nZSkge1xyXG4gICAgICBsZXQgbGFiZWw7XHJcbiAgICAgIGNvbnN0IHBhZ2VOdW1iZXIgPSB0aGlzLmNhbGN1bGF0ZVBhZ2VOdW1iZXIoXHJcbiAgICAgICAgaSxcclxuICAgICAgICBjdXJyZW50UGFnZSxcclxuICAgICAgICBwYWdpbmF0aW9uUmFuZ2UsXHJcbiAgICAgICAgdG90YWxQYWdlc1xyXG4gICAgICApO1xyXG4gICAgICBjb25zdCBvcGVuaW5nRWxsaXBzZXNOZWVkZWQgPSBpID09PSAyICYmIChpc01pZGRsZSB8fCBpc0VuZCk7XHJcbiAgICAgIGNvbnN0IGNsb3NpbmdFbGxpcHNlc05lZWRlZCA9XHJcbiAgICAgICAgaSA9PT0gcGFnaW5hdGlvblJhbmdlIC0gMSAmJiAoaXNNaWRkbGUgfHwgaXNTdGFydCk7XHJcbiAgICAgIGlmIChlbGxpcHNlc05lZWRlZCAmJiAob3BlbmluZ0VsbGlwc2VzTmVlZGVkIHx8IGNsb3NpbmdFbGxpcHNlc05lZWRlZCkpIHtcclxuICAgICAgICBsYWJlbCA9ICcuLi4nO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxhYmVsID0gcGFnZU51bWJlcjtcclxuICAgICAgfVxyXG4gICAgICBwYWdlcy5wdXNoKHtcclxuICAgICAgICBsYWJlbCxcclxuICAgICAgICB2YWx1ZTogcGFnZU51bWJlcixcclxuICAgICAgfSk7XHJcbiAgICAgIGkrKztcclxuICAgIH1cclxuICAgIHJldHVybiBwYWdlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdpdmVuIHRoZSBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2Ugb2YgcGFnaW5hdGlvbiBsaW5rcyBbaV0sXHJcbiAgICogZmlndXJlIG91dCB3aGF0IHBhZ2UgbnVtYmVyIGNvcnJlc3BvbmRzIHRvIHRoYXQgcG9zaXRpb24uXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVQYWdlTnVtYmVyKFxyXG4gICAgaTogbnVtYmVyLFxyXG4gICAgY3VycmVudFBhZ2U6IG51bWJlcixcclxuICAgIHBhZ2luYXRpb25SYW5nZTogbnVtYmVyLFxyXG4gICAgdG90YWxQYWdlczogbnVtYmVyXHJcbiAgKSB7XHJcbiAgICBjb25zdCBoYWxmV2F5ID0gTWF0aC5jZWlsKHBhZ2luYXRpb25SYW5nZSAvIDIpO1xyXG4gICAgaWYgKGkgPT09IHBhZ2luYXRpb25SYW5nZSkge1xyXG4gICAgICByZXR1cm4gdG90YWxQYWdlcztcclxuICAgIH0gZWxzZSBpZiAoaSA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gaTtcclxuICAgIH0gZWxzZSBpZiAocGFnaW5hdGlvblJhbmdlIDwgdG90YWxQYWdlcykge1xyXG4gICAgICBpZiAodG90YWxQYWdlcyAtIGhhbGZXYXkgPCBjdXJyZW50UGFnZSkge1xyXG4gICAgICAgIHJldHVybiB0b3RhbFBhZ2VzIC0gcGFnaW5hdGlvblJhbmdlICsgaTtcclxuICAgICAgfSBlbHNlIGlmIChoYWxmV2F5IDwgY3VycmVudFBhZ2UpIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudFBhZ2UgLSBoYWxmV2F5ICsgaTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gaTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==