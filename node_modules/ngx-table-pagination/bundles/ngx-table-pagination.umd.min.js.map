{"version":3,"sources":["../../../projects/ngx-table-pagination/src/lib/pagination.service.ts","../../../projects/ngx-table-pagination/src/lib/pagination.component.ts","../../../projects/ngx-table-pagination/src/lib/pagination.directive.ts","../../../projects/ngx-table-pagination/src/lib/pagination.pipe.ts","../../../projects/ngx-table-pagination/src/lib/pagination.module.ts"],"names":["PaginationService","this","change","EventEmitter","instances","DEFAULT_ID","prototype","defaultId","register","instance","id","updateInstance","changed","prop","getCurrentPage","currentPage","setCurrentPage","page","Math","ceil","totalItems","itemsPerPage","emit","setTotalItems","setItemsPerPage","getInstance","clone","obj","target","i","hasOwnProperty","coerceToBoolean","input","PaginationComponent","maxSize","previousLabel","nextLabel","screenReaderPaginationLabel","screenReaderPageLabel","screenReaderCurrentLabel","pageChange","pageBoundsCorrection","_directionLinks","_autoHide","_responsive","Object","defineProperty","value","Component","args","selector","template","changeDetection","ChangeDetectionStrategy","OnPush","encapsulation","ViewEncapsulation","None","Input","Output","PaginationDirective","service","changeDetectorRef","_this","pages","pageSizes","changeSub","subscribe","updatePageLinks","markForCheck","detectChanges","inst","ngOnInit","undefined","push","ngOnChanges","changes","ngOnDestroy","unsubscribe","pageSizeChanged","event","setCurrent","previous","checkValidId","getCurrent","next","isFirstPage","isLastPage","getLastPage","getTotalItems","getStartIndex","getEndIndex","end","console","warn","correctedCurrentPage","outOfBoundCorrection","setTimeout","createPageArray","totalPages","paginationRange","halfWay","isStart","isEnd","isMiddle","ellipsesNeeded","label","pageNumber","calculatePageNumber","Directive","exportAs","ChangeDetectorRef","LARGE_NUMBER","Number","MAX_SAFE_INTEGER","PaginationPipe","state","transform","collection","Array","_id","slice","start","serverSideMode","length","createInstance","perPage","emitChange","stateIsIdentical","saveState","config","checkConfig","_a","missing","filter","Error","join","size","every","element","index","Pipe","name","pure","NgModule","declarations","imports","CommonModule","FormsModule","providers","exports"],"mappings":"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","sourcesContent":["import {EventEmitter} from '@angular/core'\r\nimport {PaginationInstance} from './pagination-instance';\r\n\r\nexport class PaginationService {\r\n\r\n    public change: EventEmitter<string> = new EventEmitter<string>();\r\n\r\n    private instances: { [id: string]: PaginationInstance } = {};\r\n    private DEFAULT_ID = 'DEFAULT_PAGINATION_ID';\r\n\r\n    public defaultId(): string { return this.DEFAULT_ID }\r\n\r\n    /**\r\n     * Register a PaginationInstance with this service. Returns a\r\n     * boolean value signifying whether the instance is new or\r\n     * updated (true = new or updated, false = unchanged).\r\n     */\r\n    public register(instance: PaginationInstance): boolean {\r\n        if (instance.id == null) {\r\n            instance.id = this.DEFAULT_ID;\r\n        }\r\n\r\n        if (!this.instances[instance.id]) {\r\n            this.instances[instance.id] = instance;\r\n            return true;\r\n        } else {\r\n            return this.updateInstance(instance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check each property of the instance and update any that have changed. Return\r\n     * true if any changes were made, else return false.\r\n     */\r\n    private updateInstance(instance: PaginationInstance): boolean {\r\n        let changed = false;\r\n        for (let prop in this.instances[instance.id]) {\r\n            if (instance[prop] !== this.instances[instance.id][prop]) {\r\n                this.instances[instance.id][prop] = instance[prop];\r\n                changed = true;\r\n            }\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * Returns the current page number.\r\n     */\r\n    public getCurrentPage(id: string): number {\r\n        if (this.instances[id]) {\r\n            return this.instances[id].currentPage;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the current page number.\r\n     */\r\n    public setCurrentPage(id: string, page: number) {\r\n        if (this.instances[id]) {\r\n            let instance = this.instances[id];\r\n            let maxPage = Math.ceil(instance.totalItems / instance.itemsPerPage);\r\n            if (page <= maxPage && 1 <= page) {\r\n                this.instances[id].currentPage = page;\r\n                this.change.emit(id);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the value of instance.totalItems\r\n     */\r\n    public setTotalItems(id: string, totalItems: number) {\r\n        if (this.instances[id] && 0 <= totalItems) {\r\n            this.instances[id].totalItems = totalItems;\r\n            this.change.emit(id);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the value of instance.itemsPerPage.\r\n     */\r\n    public setItemsPerPage(id: string, itemsPerPage: number): void {\r\n        if (this.instances[id]) {\r\n            this.instances[id].itemsPerPage = itemsPerPage;\r\n            this.change.emit(id);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a clone of the pagination instance object matching the id. If no\r\n     * id specified, returns the instance corresponding to the default id.\r\n     */\r\n    public getInstance(id: string = this.DEFAULT_ID): PaginationInstance {\r\n        if (this.instances[id]) {\r\n            return this.clone(this.instances[id]);\r\n        }\r\n        return {} as PaginationInstance;\r\n    }\r\n\r\n    /**\r\n     * Perform a shallow clone of an object.\r\n     */\r\n    private clone(obj: any): any {\r\n        const target = {};\r\n        for (const i in obj) {\r\n            if (obj.hasOwnProperty(i)) {\r\n                target[i] = obj[i];\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n}\r\n","import {\r\n  Component,\r\n  Input,\r\n  Output,\r\n  EventEmitter,\r\n  ChangeDetectionStrategy,\r\n  ViewEncapsulation,\r\n} from '@angular/core';\r\nfunction coerceToBoolean(input: string | boolean): boolean {\r\n  return !!input && input !== 'false';\r\n}\r\n\r\n/**\r\n * The default pagination controls component. Actually just a default implementation of a custom template.\r\n */\r\n@Component({\r\n  selector: 'paging-controls',\r\n  templateUrl: './pagination.component.html',\r\n  styleUrls: ['./pagination.component.css'],\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n  encapsulation: ViewEncapsulation.None,\r\n})\r\nexport class PaginationComponent {\r\n  @Input() id: string;\r\n  @Input() maxSize: number = 7;\r\n  @Input() isItemsPerPage: boolean;\r\n  // @Input() itemsPerPage;\r\n  @Input()\r\n  get directionLinks(): boolean {\r\n    return this._directionLinks;\r\n  }\r\n  set directionLinks(value: boolean) {\r\n    this._directionLinks = coerceToBoolean(value);\r\n  }\r\n  @Input()\r\n  get autoHide(): boolean {\r\n    return this._autoHide;\r\n  }\r\n  set autoHide(value: boolean) {\r\n    this._autoHide = coerceToBoolean(value);\r\n  }\r\n  @Input()\r\n  get responsive(): boolean {\r\n    return this._responsive;\r\n  }\r\n  set responsive(value: boolean) {\r\n    this._responsive = coerceToBoolean(value);\r\n  }\r\n  // @Input() isItemsNumber = false;\r\n  @Input() previousLabel: string = '';\r\n  @Input() nextLabel: string = '';\r\n  @Input() screenReaderPaginationLabel = 'Pagination';\r\n  @Input() screenReaderPageLabel: string = 'page';\r\n  @Input() screenReaderCurrentLabel: string = `You're on page`;\r\n  @Output() pageChange: EventEmitter<number> = new EventEmitter<number>();\r\n  @Output() pageBoundsCorrection: EventEmitter<number> = new EventEmitter<\r\n    number\r\n  >();\r\n\r\n  private _directionLinks: boolean = true;\r\n  private _autoHide: boolean = false;\r\n  private _responsive: boolean = false;\r\n}\r\n","import {\r\n  ChangeDetectorRef,\r\n  Directive,\r\n  EventEmitter,\r\n  Input,\r\n  Output,\r\n  OnInit,\r\n} from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\n\r\nimport { PaginationService } from './pagination.service';\r\nimport { PaginationInstance } from './pagination-instance';\r\n\r\nexport interface Page {\r\n  label: string;\r\n  value: any;\r\n}\r\n\r\n/**\r\n * This directive is what powers all pagination controls components, including the default one.\r\n * It exposes an API which is hooked up to the PaginationService to keep the PaginatePipe in sync\r\n * with the pagination controls.\r\n */\r\n@Directive({\r\n  selector: 'pagination-template,[pagination-template]',\r\n  exportAs: 'paginationApi',\r\n})\r\nexport class PaginationDirective implements OnInit {\r\n  @Input() id: string;\r\n  @Input() maxSize = 7;\r\n\r\n  @Output() pageChange: EventEmitter<number> = new EventEmitter<number>();\r\n  @Output() pageBoundsCorrection: EventEmitter<number> = new EventEmitter<\r\n    number\r\n  >();\r\n  pages: Page[] = [];\r\n  pageSizes: any[] = [];\r\n  itemsPerPage: number;\r\n  private changeSub: Subscription;\r\n\r\n  constructor(\r\n    private service: PaginationService,\r\n    private changeDetectorRef: ChangeDetectorRef\r\n  ) {\r\n    this.changeSub = this.service.change.subscribe((id) => {\r\n      if (this.id === id) {\r\n        this.updatePageLinks();\r\n        this.changeDetectorRef.markForCheck();\r\n        this.changeDetectorRef.detectChanges();\r\n        const inst = this.service.getInstance(this.id);\r\n        this.itemsPerPage = inst.itemsPerPage;\r\n      }\r\n    });\r\n  }\r\n\r\n  ngOnInit() {\r\n    if (this.id === undefined) {\r\n      this.id = this.service.defaultId();\r\n    }\r\n    const inst = this.service.getInstance(this.id);\r\n    this.itemsPerPage = inst.itemsPerPage;\r\n    for (let i = 5; i <= inst.totalItems; ) {\r\n      this.pageSizes.push(i);\r\n      i += 5;\r\n    }\r\n    this.updatePageLinks();\r\n  }\r\n\r\n  ngOnChanges(changes: any) {\r\n    this.updatePageLinks();\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this.changeSub.unsubscribe();\r\n  }\r\n  pageSizeChanged(event) {\r\n    this.itemsPerPage = event;\r\n    this.service.setItemsPerPage(this.id, event);\r\n    this.setCurrent(1);\r\n    this.updatePageLinks();\r\n  }\r\n  /**\r\n   * Go to the previous page\r\n   */\r\n  previous() {\r\n    this.checkValidId();\r\n    this.setCurrent(this.getCurrent() - 1);\r\n  }\r\n\r\n  /**\r\n   * Go to the next page\r\n   */\r\n  next() {\r\n    this.checkValidId();\r\n    this.setCurrent(this.getCurrent() + 1);\r\n  }\r\n\r\n  /**\r\n   * Returns true if current page is first page\r\n   */\r\n  isFirstPage(): boolean {\r\n    return this.getCurrent() === 1;\r\n  }\r\n\r\n  /**\r\n   * Returns true if current page is last page\r\n   */\r\n  isLastPage(): boolean {\r\n    return this.getLastPage() === this.getCurrent();\r\n  }\r\n\r\n  /**\r\n   * Set the current page number.\r\n   */\r\n  setCurrent(page: number) {\r\n    this.pageChange.emit(page);\r\n  }\r\n\r\n  /**\r\n   * Get the current page number.\r\n   */\r\n  getCurrent(): number {\r\n    return this.service.getCurrentPage(this.id);\r\n  }\r\n\r\n  /**\r\n   * Returns the last page number\r\n   */\r\n  getLastPage(): number {\r\n    const inst = this.service.getInstance(this.id);\r\n    if (inst.totalItems < 1) {\r\n      // when there are 0 or fewer (an error case) items, there are no \"pages\" as such,\r\n      // but it makes sense to consider a single, empty page as the last page.\r\n      return 1;\r\n    }\r\n    return Math.ceil(inst.totalItems / inst.itemsPerPage);\r\n  }\r\n\r\n  getTotalItems(): number {\r\n    return this.service.getInstance(this.id).totalItems;\r\n  }\r\n  getStartIndex(): number {\r\n    const inst = this.service.getInstance(this.id);\r\n    if (inst.totalItems < inst.itemsPerPage * (inst.currentPage - 1) + 1) {\r\n      this.setCurrent(1);\r\n    }\r\n    return inst.itemsPerPage * (inst.currentPage - 1) + 1;\r\n  }\r\n\r\n  getEndIndex(): number {\r\n    const inst = this.service.getInstance(this.id);\r\n    const end = inst.itemsPerPage * inst.currentPage;\r\n    if (inst.totalItems < end) {\r\n      return inst.totalItems;\r\n    }\r\n    return end;\r\n  }\r\n  private checkValidId(): void {\r\n    if (this.service.getInstance(this.id).id == null) {\r\n      console.warn(\r\n        `PaginationControlsDirective: the specified id \"${this.id}\" does not match any registered PaginationInstance`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the page links and checks that the current page is valid. Should run whenever the\r\n   * PaginationService.change stream emits a value matching the current ID, or when any of the\r\n   * input values changes.\r\n   */\r\n  private updatePageLinks() {\r\n    const inst = this.service.getInstance(this.id);\r\n    const correctedCurrentPage = this.outOfBoundCorrection(inst);\r\n\r\n    if (correctedCurrentPage !== inst.currentPage) {\r\n      setTimeout(() => {\r\n        this.pageBoundsCorrection.emit(correctedCurrentPage);\r\n        this.pages = this.createPageArray(\r\n          inst.currentPage,\r\n          inst.itemsPerPage,\r\n          inst.totalItems,\r\n          this.maxSize\r\n        );\r\n      });\r\n    } else {\r\n      this.pages = this.createPageArray(\r\n        inst.currentPage,\r\n        inst.itemsPerPage,\r\n        inst.totalItems,\r\n        this.maxSize\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks that the instance.currentPage property is within bounds for the current page range.\r\n   * If not, return a correct value for currentPage, or the current value if OK.\r\n   */\r\n  private outOfBoundCorrection(instance: PaginationInstance): number {\r\n    const totalPages = Math.ceil(instance.totalItems / instance.itemsPerPage);\r\n    if (totalPages < instance.currentPage && 0 < totalPages) {\r\n      return totalPages;\r\n    } else if (instance.currentPage < 1) {\r\n      return 1;\r\n    }\r\n\r\n    return instance.currentPage;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of Page objects to use in the pagination controls.\r\n   */\r\n  private createPageArray(\r\n    currentPage: number,\r\n    itemsPerPage: number,\r\n    totalItems: number,\r\n    paginationRange: number\r\n  ): Page[] {\r\n    // paginationRange could be a string if passed from attribute, so cast to number.\r\n    paginationRange = +paginationRange;\r\n    const pages = [];\r\n    const totalPages = Math.ceil(totalItems / itemsPerPage);\r\n    const halfWay = Math.ceil(paginationRange / 2);\r\n\r\n    const isStart = currentPage <= halfWay;\r\n    const isEnd = totalPages - halfWay < currentPage;\r\n    const isMiddle = !isStart && !isEnd;\r\n\r\n    const ellipsesNeeded = paginationRange < totalPages;\r\n    let i = 1;\r\n\r\n    while (i <= totalPages && i <= paginationRange) {\r\n      let label;\r\n      const pageNumber = this.calculatePageNumber(\r\n        i,\r\n        currentPage,\r\n        paginationRange,\r\n        totalPages\r\n      );\r\n      const openingEllipsesNeeded = i === 2 && (isMiddle || isEnd);\r\n      const closingEllipsesNeeded =\r\n        i === paginationRange - 1 && (isMiddle || isStart);\r\n      if (ellipsesNeeded && (openingEllipsesNeeded || closingEllipsesNeeded)) {\r\n        label = '...';\r\n      } else {\r\n        label = pageNumber;\r\n      }\r\n      pages.push({\r\n        label,\r\n        value: pageNumber,\r\n      });\r\n      i++;\r\n    }\r\n    return pages;\r\n  }\r\n\r\n  /**\r\n   * Given the position in the sequence of pagination links [i],\r\n   * figure out what page number corresponds to that position.\r\n   */\r\n  private calculatePageNumber(\r\n    i: number,\r\n    currentPage: number,\r\n    paginationRange: number,\r\n    totalPages: number\r\n  ) {\r\n    const halfWay = Math.ceil(paginationRange / 2);\r\n    if (i === paginationRange) {\r\n      return totalPages;\r\n    } else if (i === 1) {\r\n      return i;\r\n    } else if (paginationRange < totalPages) {\r\n      if (totalPages - halfWay < currentPage) {\r\n        return totalPages - paginationRange + i;\r\n      } else if (halfWay < currentPage) {\r\n        return currentPage - halfWay + i;\r\n      } else {\r\n        return i;\r\n      }\r\n    } else {\r\n      return i;\r\n    }\r\n  }\r\n}\r\n","import {Pipe, PipeTransform} from '@angular/core';\r\nimport {PaginationService} from './pagination.service';\r\nimport {PaginationInstance} from './pagination-instance';\r\n\r\nconst LARGE_NUMBER = Number.MAX_SAFE_INTEGER;\r\n\r\nexport type Collection<T> = T[] | ReadonlyArray<T>;\r\n\r\nexport interface PaginatePipeArgs {\r\n  id?: string;\r\n  itemsPerPage?: string | number;\r\n        currentPage?: string | number;\r\n    totalItems?: string | number;\r\n}\r\n\r\nexport interface PipeState {\r\n    collection: any[];\r\n    size: number;\r\n    start: number;\r\n    end: number;\r\n    slice: any[];\r\n}\r\n\r\n@Pipe({\r\n    name: 'paginate',\r\n    pure: false\r\n})\r\nexport class PaginationPipe implements PipeTransform{\r\n\r\n    // store the values from the last time the pipe was invoked\r\n    private state: { [id: string]: PipeState } = {};\r\n\r\n    constructor(private service: PaginationService) {\r\n    }\r\n\r\n    public transform<T, U extends Collection<T>>(collection: U, args: PaginatePipeArgs): U {\r\n\r\n        // When an observable is passed through the AsyncPipe, it will output\r\n        // `null` until the subscription resolves. In this case, we want to\r\n        // use the cached data from the `state` object to prevent the NgFor\r\n        // from flashing empty until the real values arrive.\r\n        if (!(collection instanceof Array)) {\r\n            const _id = args.id || this.service.defaultId();\r\n            if (this.state[_id]) {\r\n                return this.state[_id].slice as U;\r\n            } else {\r\n                return collection;\r\n            }\r\n        }\r\n\r\n        const serverSideMode = args.totalItems && args.totalItems !== collection.length;\r\n\r\n        const instance = this.createInstance(collection, args);\r\n        const id = instance.id;\r\n        let start, end;\r\n        let perPage = instance.itemsPerPage;\r\n\r\n        const emitChange = this.service.register(instance);\r\n\r\n        if (!serverSideMode && collection instanceof Array) {\r\n            perPage = +perPage || LARGE_NUMBER;\r\n            start = (instance.currentPage - 1) * perPage;\r\n            end = start + perPage;\r\n\r\n            const isIdentical = this.stateIsIdentical(id, collection, start, end);\r\n            if (isIdentical) {\r\n                return this.state[id].slice as U;\r\n            } else {\r\n                const slice = collection.slice(start, end);\r\n                this.saveState(id, collection, slice, start, end);\r\n                this.service.change.emit(id);\r\n                return slice as U;\r\n            }\r\n        } else {\r\n            if (emitChange) {\r\n                this.service.change.emit(id);\r\n            }\r\n\r\n            // save the state for server-side collection to avoid null\r\n            // flash as new data loads.\r\n            this.saveState(id, collection, collection, start, end);\r\n\r\n            return collection;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create an PaginationInstance object, using defaults for any optional properties not supplied.\r\n     */\r\n    private createInstance(collection: any[], config: PaginatePipeArgs): PaginationInstance {\r\n      this.checkConfig(config);\r\n      const id = config.id != null ? config.id : this.service.defaultId();\r\n      if (config.itemsPerPage) {\r\n        if (!this.service.getInstance(id)?.itemsPerPage) {\r\n                  this.service.setItemsPerPage(id, +config.itemsPerPage);\r\n        }\r\n\r\n      }\r\n\r\n      const perPage = (config.itemsPerPage && !this.service.getInstance(id).itemsPerPage) ? config.itemsPerPage :\r\n        this.service.getInstance(id).itemsPerPage;\r\n      return {\r\n          id: config.id != null ? config.id : this.service.defaultId(),\r\n          itemsPerPage: +perPage || 5,\r\n          currentPage: +config.currentPage || 1,\r\n          totalItems: +config.totalItems || collection.length\r\n        };\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * Ensure the argument passed to the filter contains the required properties.\r\n     */\r\n    private checkConfig(config: PaginatePipeArgs): void {\r\n        const required = [ 'currentPage'];\r\n\r\n        const missing = required.filter(prop => !(prop in config));\r\n        if (0 < missing.length) {\r\n            throw new Error(`PaginatePipe: Argument is missing the following required properties: ${missing.join(', ')}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * To avoid returning a brand new array each time the pipe is run, we store the state of the sliced\r\n     * array for a given id. This means that the next time the pipe is run on this collection & id, we just\r\n     * need to check that the collection, start and end points are all identical, and if so, return the\r\n     * last sliced array.\r\n     */\r\n    private saveState(id: string, collection: any[], slice: any[], start: number, end: number) {\r\n        this.state[id] = {\r\n            collection,\r\n            size: collection.length,\r\n            slice,\r\n            start,\r\n            end\r\n        };\r\n    }\r\n\r\n    /**\r\n     * For a given id, returns true if the collection, size, start and end values are identical.\r\n     */\r\n    private stateIsIdentical(id: string, collection: any[], start: number, end: number): boolean {\r\n        const state = this.state[id];\r\n        if (!state) {\r\n            return false;\r\n        }\r\n        const isMetaDataIdentical = state.size === collection.length &&\r\n            state.start === start &&\r\n            state.end === end;\r\n\r\n        if (!isMetaDataIdentical) {\r\n            return false;\r\n        }\r\n\r\n        return state.slice.every((element, index) => element === collection[start + index]);\r\n    }\r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport{FormsModule} from '@angular/forms';\r\nimport { PaginationComponent } from './pagination.component';\r\nimport { PaginationService } from './pagination.service';\r\nimport { PaginationDirective } from './pagination.directive';\r\nimport { PaginationPipe } from './pagination.pipe';\r\nexport { PaginationInstance } from './pagination-instance';\r\n\r\nexport {PaginationService} from './pagination.service';\r\nexport {PaginationComponent} from './pagination.component';\r\nexport {PaginationDirective} from './pagination.directive';\r\nexport {PaginationPipe} from './pagination.pipe';\r\n\r\n@NgModule({\r\n  declarations: [\r\n  PaginationComponent,\r\n  PaginationPipe,\r\n  PaginationDirective],\r\n  imports: [\r\n    CommonModule,\r\n    FormsModule\r\n  ],\r\n  providers: [PaginationService],\r\n  exports: [  PaginationComponent,\r\n  PaginationPipe,\r\n  PaginationDirective]\r\n})\r\nexport class NgxTablePaginationModule { }\r\n"]}